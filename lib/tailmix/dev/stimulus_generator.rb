# frozen_string_literal: true

module Tailmix
  module Dev
    class StimulusGenerator
      def initialize(definition, component_name)
        @definition = definition
        @component_name = component_name
        @stimulus_defs = definition.elements.values.flat_map(&:stimulus).flat_map(&:definitions)
      end

      def scaffold(controller_name = nil, show_docs: false)
        controllers_to_generate = controller_name ? [ controller_name.to_s ] : all_controllers

        output = controllers_to_generate.map do |name|
          defs = @stimulus_defs.select { |d| d[:controller] == name }

          show_docs ? generate_docs_for(name, defs) + "\n" : generate_js_for(name, defs) + ("-" * 60) + "\n"
        end
        output.join("\n")
      end

      private

      def generate_docs_for(controller_name, defs)
        output = [ "Stimulus:" ]
        output << "  - on `#{controller_name}` controller:"
        targets = defs.select { |d| d[:type] == :target }.map { |d| d[:name] }
        output << "    - Targets: #{targets.join(', ')}" if targets.any?

        actions = action_methods(defs)
        output << "    - Actions: #{actions.join(', ')}" if actions.any?

        values = defs.select { |d| d[:type] == :value }.map { |d| d[:name] }
        output << "    - Values: #{values.join(', ')}" if values.any?

        output.join("\n")
      end

      def generate_js_for(controller_name, defs)
        targets = defs.select { |d| d[:type] == :target }.map { |d| "'#{d[:name]}'" }.uniq.join(", ")

        payload_actions = defs.select { |d| d[:type] == :action_payload }
        simple_values = defs.select { |d| d[:type] == :value }

        value_names = (payload_actions.map { |d| d[:value_name] } + simple_values.map { |d| d[:name] })
          .uniq.map { |name| "#{snake_to_camel(name.to_s)}: Object" }.join(", ")

        isomorphic_methods = payload_actions.map do |payload_def|
          action_name_camel = snake_to_camel(payload_def[:action_name].to_s)
          value_name_camel = snake_to_camel(payload_def[:value_name].to_s)

          "  #{action_name_camel}(event) {\n     if (event) event.preventDefault();\n     Tailmix.run({ config: this.#{value_name_camel}Value, controller: this });\n  }"
        end.join.strip

        standard_action_names = defs.select { |d| d[:type] == :action }
                                    .flat_map { |d| extract_action_methods(d[:data]) }
                                    .uniq

        implemented_action_names = payload_actions.map { |d| d[:action_name].to_s }
        stub_methods = (standard_action_names - implemented_action_names).map do |method_name|
          method_name_camel = snake_to_camel(method_name)
          "  #{method_name_camel}() {\n    console.log('#{controller_name}##{method_name_camel} fired');\n  }"
        end.join("\n\n")

        js_methods = [isomorphic_methods, stub_methods].reject(&:empty?).join("\n\n")

        <<~JAVASCRIPT
          // Generated by Tailmix for the "#{controller_name}" controller
          // Path: app/javascript/controllers/#{controller_name.tr('_', '-')}_controller.js
          import { Controller } from "@hotwired/stimulus"
          import Tailmix from "tailmix"

          export default class extends Controller {
            static targets = [#{targets}]
            static values = { #{value_names} }

            connect() {
              console.log("#{controller_name} controller connected to", this.element);
            }
            #{js_methods}
          }
        JAVASCRIPT
      end

      def extract_action_methods(action_data)
        case action_data[:type]
        when :raw
          action_data[:content].to_s.scan(/#(\w+)/).flatten
        when :hash
          action_data[:content].values.map(&:to_s)
        when :tuple
          [action_data[:content][1].to_s]
        else
          []
        end
      end

      def all_controllers
        @stimulus_defs.map { |d| d[:controller] }.compact.uniq
      end

      def action_methods(defs)
        defs.select { |d| d[:type] == :action }.flat_map do |action_definition|
          data = action_definition[:data]
          case data[:type]
          when :raw
            data[:content].to_s.scan(/#(\w+)/).flatten
          when :hash
            data[:content].values.map(&:to_s)
          when :tuple
            [ data[:content][1].to_s ]
          else
            []
          end
        end.uniq
      end

      def snake_to_camel(str)
        str.split("_").map.with_index { |word, i| i.zero? ? word : word.capitalize }.join
      end
    end
  end
end
